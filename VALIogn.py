#!/usr/bin/python3
#########################################################################
# This program VALIdate the signature record (G) for an IGC file generated by an OGN/IGC tracker
# OGN/IGC tracker project
#########################################################################
import string
import socket
import time
import datetime
import sys
import os.path
import MySQLdb                          # the SQL data base routines^M
import argparse
from datetime import datetime, timedelta# Python 3 code to demonstrate the 
# working of MD5 (byte - byte) 
import json
import requests
import urllib.request, urllib.error, urllib.parse
import hashlib 
import base64
from Crypto.PublicKey import DSA
from Crypto.PublicKey import ECC
from Crypto.Hash      import SHA256
from Crypto.Signature import DSS, pss
from Crypto.Random    import get_random_bytes
from Crypto.Cipher    import AES, PKCS1_OAEP
import binascii
from pkcsfuncs import *

#
########################################################################
#
secret='c7675a2e6297b8e4990c0a29118914c0d4ee17ec'

#DDB_URL = "http://ddb.glidernet.org/download/?j=1"
DDB_URL = "http://acasado.es:60082/download/?j=2"  				# the OGN DDB source
REG_URL = "http://acasado.es:60080/registration/V1/?action=getdata&token="  	# the OGN registration source
#REG_URL = "http://localhost:8181/?action=getdata&token="  			# the OGN registration source

def getddbdata(reg):                        # get the data from the API server

    if reg == '':
       url=DDB_URL
    else:
       url=DDB_URL+'&registration='+reg
    req = urllib.request.Request(url)
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)         # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                  # convert to JSON

    return j_obj   

def getregdata(reg, mac, devid=''):         # get the data from the API servera
    date = datetime.utcnow()                # get the date
    dte = date.strftime("%Y-%m-%d")         # today's date
    nonce = base64.b64encode(dte.encode('utf-8')).decode('ascii')
    url=REG_URL+nonce
    if reg == '':
       url=url+'&registration=NONE'
    else:
       url=url+'&registration='+reg
    url=url+'&mac='+mac+'&devid='+devid
    print(url)
    req = urllib.request.Request(url)
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)         # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                  # convert to JSON
    return j_obj   

def genkeys():				# temp gen the keys
    listofkpECC=[]
    listofkpECC=ECCgenlistofkp(listofkpECC, 2)
    k      = listofkpECC[0]
    kk     = k['private_key'].encode('ascii')
    priecc = ECC.import_key(kk)
    kk     = k['public_key'].encode('ascii')
    pubecc = ECC.import_key(kk)
    return (priecc,pubecc)
    
def testsign(grec, prik, pubk):		# temp test signture

    #print("Has a valid key:", prik.has_private(), prik)

    h      = SHA256.new(grec.encode('ascii'))
    signer = DSS.new(prik, 'fips-186-3')
    signature = signer.sign(h)
    #print ("signature:",signature)
    return signature
#
# ----------------------------------------------------------------------------------------------------------
#
programver = 'V1.0'
pidfile="/tmp/TRKS.pid"
print("\n\nStart VALIogn  "+programver)
print("=====================")
################################################################
print("Program Version:", time.ctime(os.path.getmtime(__file__)))
print("==========================================")
date = datetime.utcnow()                # get the date
dte = date.strftime("%y%m%d")           # today's date
print("\nDate: ", date, "UTC on SERVER:", socket.gethostname(), "Process ID:", os.getpid())
date = datetime.now()                   # local time
parser = argparse.ArgumentParser(description="OGN Push to the OGN APRS the delayed tracks")
parser.add_argument('-p',  '--print',     required=False,
                    dest='prt',   action='store', default=False)
parser.add_argument('-f',  '--file',     required=True,
                    dest='filename',   action='store', default='NOFILENAME')
args = parser.parse_args()
prt        = args.prt                   # print on|off
filename   = args.filename              # FileName
if filename.find('.IGC') < 1:		# check that is an IGC file
   print ("Wrong FileName:", filename)
   exit(-1)
try:
            f = open(filename, "rb")
except IOError as e:
            print(e)
            exit(-1)
data = f.read()				# read the whole file
f.close()
ddd=data.decode('ascii')		# convert from binay to ASCII
print("** %s **" % filename)
limit=0
l = len(data) - 2

while l > 0:				# scna for the G record (\nG)
     #print (data[l], data[l+1], l, data[l:].decode('ascii'))
     if data[l] == 71 and data[l-1] == 10: # G precceded by newline
        grec=data[l+1:-1].decode('ascii')
        limit=l
        break				# found it
     l -= 1
h = hashlib.new('MD5')			# use MD5
h.update(data[0:limit])			# get the value
try:
        hexdigest = h.hexdigest()	# get the message digest
except TypeError:
        hexdigest = h.hexdigest(128)
print("%s: %s" % ('MD5', hexdigest.upper()), len(hexdigest))
print("%s: %s" % ('GRE', grec), len(grec))
print()

if hexdigest.upper() == grec:		# compare the values between the message disgest and the G record 
   print ("Signature OK")
else:
   print ("Signature wrong")
   exit(-1)

l1=ddd.find('HFRHWHardwareVersion:FollowMe') 	# find the MAC value
MAC=""
if l1 > 0:
   l2=ddd[l1+30:].find('\n')
   MAC=ddd[l1+30:l1+l2+30]
print("MAC:", MAC)
l1=ddd.find('HFGIDGliderID:')		# find the DEVICE ID
reg=""
if l1 > 0:
   l2=ddd[l1+14:].find('\n')
   reg=ddd[l1+14:l1+l2+14]
print("REG:", reg)			# fine the registration ID
DDB=getddbdata(reg)			# get the data from the Devices data Base (DDB)
dev=DDB['devices']
print("DDB:", dev)
devtype=dev[0]['device_type']		# device type
devid=dev[0]['device_id']		# deviceID
#print("DevT:", devtype, devid)
r=getregdata(reg, MAC, devid)		# get the data from the REGISTRATION database
rr=r['registration']
#print (rr)
IPaddr=rr[0]['reg_IPaddr']		# IP addr of when the device was registered
RegTime=rr[0]['reg_time']		# Time of when it was registered
					# Public key from the device
PublicKey="-----BEGIN PUBLIC KEY-----\n"+rr[0]['reg_PublicKey']+"\n-----END PUBLIC KEY-----"
Rreg=rr[0]['reg_registration']		# registration ID from the registration DB
Rdevid=rr[0]['reg_devid']		# deviceID from the registration DB
if Rreg != reg or Rdevid != devid:	# check if are the same ??
   print ("Invalid registration:", rr)
   exit(-1)
PublicKey=PublicKey.encode('ascii')	# convert Public Key tp ASCII
print (IPaddr, RegTime, PublicKey)
pubecc = ECC.import_key(PublicKey)	# get the PUBLIC KEY from the PEM format
#print (pubecc)
h      = SHA256.new(grec.encode('ascii')) # get the MD from the G record
verifier = DSS.new(pubecc, 'fips-186-3') # build the ECDSA verifier
try:
   verifier.verify(h, grec)		# verify the signature
   print ("The message is authentic.")
except ValueError:
   print ("The message is not authentic.")

#					Just a test of the concept
prik,pubk=genkeys()			# genjust a pair of keys to test
sign=testsign(grec, prik, pubk)		# sign the G record just to test

h      = SHA256.new(grec.encode('ascii')) # get the MD of the G record
verifier = DSS.new(pubk, 'fips-186-3')	# ECDSA verifier
try:
   verifier.verify(h, sign)		# verify signature
   print ("The message is authentic.")
except ValueError:
   print ("The message is not authentic.")

