#!/usr/bin/python3
#########################################################################
# This program VALIdate the signature record (G) for an IGC file generated by an OGN/IGC tracker
# OGN/IGC tracker project
#########################################################################
import string
import socket
import time
import sys
import os
import os.path
from os import path
import argparse
from   datetime import datetime, timedelta
import json
import requests
import urllib.request, urllib.error, urllib.parse
import base64
from binascii         import unhexlify
from mbedtls          import pk
from mbedtls          import version
from mbedtls          import hashlib
from mbedtls          import cipher
from mbedtls.mpi      import MPI
from mbedtls._platform      import *
from mbedtls._ringbuf      import *
#from mbedtls          import *
#from pkcsfuncs import *

#
########################################################################
#
secret='c7675a2e6297b8e4990c0a29118914c0d4ee17ec'

#DDB_URL = "http://ddb.glidernet.org/download/?j=1"
DDB_URL = "http://acasado.es:60082/download/?j=2"  				# the OGN DDB source
REG_URL = "http://acasado.es:60080/registration/V1/?action=getdata&token="  	# the OGN registration source
#REG_URL = "http://localhost:8181/?action=getdata&token="  			# the OGN registration source

def getddbdata(reg):                        # get the data from the API server

    if reg == '':
       url=DDB_URL
    else:
       url=DDB_URL+'&registration='+reg
    req = urllib.request.Request(url)
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)         # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                  # convert to JSON

    return j_obj   

def getregdata(reg, mac, devid='', prt=False):         # get the data from the API servera
    date = datetime.utcnow()                # get the date
    dte = date.strftime("%Y-%m-%d")         # today's date
    nonce = base64.b64encode(dte.encode('utf-8')).decode('ascii')
    url=REG_URL+nonce
    if reg == '':                            # if registration is provided
       url=url+'&registration=NONE'
    else:
       url=url+'&registration='+reg
    url=url+'&mac='+mac+'&devid='+devid
    if prt:
       print("Calling to:",url)
    req = urllib.request.Request(url)        # prepare the request
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)          # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                   # convert to JSON
    return j_obj   
#
# ----------------------------------------------------------------------------------------------------------
#
#def genkeys():				                     # temp gen the keys
    #listofkpECC=[]
    #listofkpECC=ECCgenlistofkp(listofkpECC, 2)
    #k      = listofkpECC[0]
    #kk     = k['private_key'].encode('ascii')
    #priecc = ECC.import_key(kk)
    #kk     = k['public_key'].encode('ascii')
    #pubecc = ECC.import_key(kk)
    #return (priecc,pubecc)
    
def testsign(grec, prik, pubk, prt=False):	# temp test signture

    if prt:
      print("Has a valid key:", prik.has_private(), prik)


    h=hashlib.sha256(grec.encode('ascii'))
    signer = DSS.new(prik, 'fips-186-3')
    signature = signer.sign(h)
    if prt:
       print ("Signature:",signature)
    return signature
#
def signmessage(message, PrivatKey, prt=False):	# this is the way how the tracker signs the IGC file
#						message is the content of the IGC file except the G record
#						prik is the private key
    i=len(PrivatKey)
    l=7672
    while i < l:				# padding with zeros
          PrivatKey += b'\x00'
          i += 1

    priecc = pk.ECC.from_buffer(PrivatKey)	# use the private key key in PEM format
    signature = priecc.sign(message, digestmod='sha256')
    if prt:
       print ("PGM Signature: len=>",len(signature), signature.hex().upper(), "\n")	# print it if requested
    return signature

#
# ----------------------------------------------------------------------------------------------------------
#
programver = 'V1.0'
pidfile="/tmp/TRKS.pid"
print("\n\nStart VALI-AVX  "+programver)
print("=====================")
################################################################
if os.name != 'nt':			# just report the version, not valid on NT or bundles from pyinstaller
   bundle_dir = path.abspath(path.dirname(__file__))
   if bundle_dir[0:9] != "/tmp/_MEI":
      print("Program Version:", time.ctime(os.path.getmtime(path.abspath(__file__))))
      print("=========================================")
   import MySQLdb                       # the SQL data base routines^M
date = datetime.utcnow()                # get the date
dte = date.strftime("%y%m%d")           # today's date
print("\nDate: ", date, "UTC on SERVER:", socket.gethostname(), "Process ID:", os.getpid(), os.name)
date = datetime.now()                   # local time
parser = argparse.ArgumentParser(description="VALI-AVX validate the signature of the .IGC file generated by the OGN/IGC Tracker ")
parser.add_argument('-p',  '--print',     required=False,
                    dest='prttxt',   action='store', default=False)
parser.add_argument('-d',  '--debug',     required=False,
                    dest='debugtxt',   action='store', default=False)
parser.add_argument( dest='filename',   action='store', default='NOFILENAME')
args = parser.parse_args()
prttxt     = args.prttxt                # print on|off
if prttxt == 'True':
   prt=True
else:
   prt=False
debugtxt     = args.debugtxt                # print on|off
if debugtxt == 'True':
   debug=True
   prt=True
else:
   debug=False
filename   = args.filename              # FileName
if filename.find('.IGC') < 1: 
   if filename.find('.igc') < 1:	# check that is an IGC file
      print (">>> Wrong FileName:", filename)
      sys.stdout.flush()
      os._exit(-1)
try:
            f = open(filename, "rb")
except IOError as e:
            print(e)
            sys.stdout.flush()
            os._exit(-1)
data = f.read()			        # read the whole file
f.close()
sys.stdout.flush()
ddd=data.decode('ascii')	        # convert from binay to ASCII
print("** Validating IGC file: %s **" % filename, prt, debug)
limit=0
l = len(data) - 2
grecsha=''
grec=""					# G record where it is the tracker signature of the file in HEX
while l > 0:			        # scan for the G record (\nG)
     #print (data[l], data[l-1], l, data[l:].decode('ascii'))
     if data[l] == 71 and data[l-1] == 10 :
        grecsign=data[l+1:-1].decode('ascii')
        if data[l-66] == 71 : # G precceded by newline
           grecsha=data[l-65:l-1].decode('ascii')
        limit=l
        break			        # found it
     l -= 1
if l == 0:
   print (">>> G record not found ")
   os._exit(-1)
message=data[0:l-66]			# input for compute the message digest
# ---------------------------------------------------------------------------------------------- #
if debug:
	print ("SHA", grecsha)
	print ("SIG", grecsign)
	print ("message length", len(message))

TRKsignbin=unhexlify(grecsign)		# the message signature ECDSA convert from HEX to binary
if prt:
   print("%s: %s \nSIGN: %s " %  ('GRECORDs SHA:', grecsha, grecsign), len(TRKsignbin))
   print("===========================================================================")
# --------------------------------------------------------------------- #
# check the first G record the message digest
# ===========================================
#
PGMhash256=hashlib.sha256(message).hexdigest().upper()
#print ("HHH", message, PGMhash256)

if PGMhash256 == grecsha:      	# compare the values between the message disgest and the G record 
   print ("SHA256 Signature OK")
else:
   print ("SHA256 Signature wrong")
   sys.stdout.flush()
   os._exit(-1)

sys.stdout.flush()
# --------------------------------------------------------------------- #
# check now the MAC, registration
# --------------------------------------------------------------------- #
l1=ddd.find('HFRHWHardwareVersion:FollowMe') 	# find the MAC value
MAC=""
if l1 > 0:
   l2=ddd[l1+30:].find('\n')
   MAC=ddd[l1+30:l1+l2+30]
l1=ddd.find('HFGIDGliderID:')		# find the DEVICE ID
reg=""
if l1 > 0:
   l2 =ddd[l1+14:].find('\n')
   reg=ddd[l1+14:l1+l2+14]		# the registration EC-xxx
DDB=getddbdata(reg)			# get the data from the OGN Devices data Base (DDB)
dev=DDB['devices']
if prt:
   print("MAC:", MAC, "REG:", reg, "DDB:", dev)	# find the registration ID
devtype=dev[0]['device_type']		# device type
devid  =dev[0]['device_id']		# deviceID
#print("DevT:", devtype, devid)
r=getregdata(reg, MAC, devid, prt=prt)	# get the data from the REGISTRATION database
rr     =r['registration']
IPaddr =rr[0]['reg_IPaddr']		# IP addr of when the device was registered
RegTime=rr[0]['reg_time']		# Time of when it was registered
					# Public key from the device
PublicKey=rr[0]['reg_PublicKey'].encode('ascii')	# public key from the registration DB
Rreg=rr[0]['reg_registration']		# registration ID from the registration DB
Rdevid=rr[0]['reg_devid']		# deviceID from the registration DB
PublicKeyLen=len(PublicKey)
i=0
k=b''
nl=10
while i < PublicKeyLen:			# eliminate the double backslash 
  
    if PublicKey[i] == 92:
       k +=  nl.to_bytes(1,'big')
       i +=2
    else:
       k += PublicKey[i].to_bytes(1, 'big')
       i += 1
if prt:
   print ("PublicKey from TRK registration:", len(k), k)
# -------------------------------------------------------------------------------- #
#
# testing trick
#
# -------------------------------------------------------------------------------- #
if debug:
					# get the private kesy and the public key for the aux files 
   with open('pubkey.PEM', mode='rb') as keyfile:
     		PublicKey = keyfile.read()
   print ("PublicKey from file:", len(PublicKey), PublicKey)

   with open('prikey.PEM', mode='r') as keyfile:
     		PrivatKey = keyfile.read().encode('ascii')

   with open('tracker.sign.bin', mode='rb') as keyfile: 	# also the binary signature file
     		trksignbin = keyfile.read()

   if trksignbin == TRKsignbin:
      print ("bin signatures matches")
   else: 
      print (">>>>> do not match", TRKsignbin, trksignbin)
      exit(-1)

   PGMsignature=signmessage(message,PrivatKey, prt=True) 	# sign the message using the private key from the PEM file

   print ("BIN Signature: len=>",len(TRKsignbin), TRKsignbin.hex().upper(), "\n")	# print it if requested
   print ("BIN & PGM signatures Matches:", PGMsignature == TRKsignbin)
   
   if k == PublicKey:
      print ("key matches")
      PublicKey = k  
else:
   PublicKey = k  
    
# end of testing trick
# -------------------------------------------------------------------------------- #
if Rreg != reg or Rdevid != devid:	# check if are the same ??
   print (">>> Invalid registration:", reg, Rreg, devid, Rdevid, "\n", rr)
   sys.stdout.flush()
   os._exit(-1)
if prt:
   print ("IP+RegTime+PK:",  IPaddr, RegTime, PublicKey)
# ------------------------------ Validation process ------------------------------ #
i=len(PublicKey)
l=7672
while i < l:				# padding with zeros
      PublicKey += b'\x00'
      i += 1

trk  = pk.ECC.from_buffer(PublicKey)	# use the public key in PEM format
if debug:
   print("PEM key lenght:", len(PublicKey), "Key size PEM:", trk.key_size, "Message length:", len(message))
# 					# checkif valid or not
if(trk.verify(message, TRKsignbin, digestmod='sha256')):
    print("Authentic trk & PEM\n", message[0:60])
    rc=0				# IGC valid
else:
    print(">>> NOT Authentic trk ------------------------------")
    rc=-1				# IGC file invalid
if debug:				# versify using the signature generated on this program from the private key
   if(trk.verify(message, PGMsignature, digestmod='sha256')):
       print("Authentic pgm & PEM\n", message[0:60])
       rc=0				# IGC valid
   else:
       print(">>> NOT Authentic trk ------------------------------")
       rc=-1				# IGC file invalid
sys.stdout.flush()
os._exit(rc)
