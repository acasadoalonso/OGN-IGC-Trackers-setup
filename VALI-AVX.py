#!/usr/bin/python3
#########################################################################
# This program VALIdate the signature record (G) for an IGC file generated by an OGN/IGC tracker
# OGN/IGC tracker project
#########################################################################
import string
import socket
import time
import datetime
import sys
import os
import os.path
import argparse
from datetime import datetime, timedelta# Python 3 code to demonstrate the 
# working of MD5 (byte - byte) 
import json
import requests
import urllib.request, urllib.error, urllib.parse
import hashlib 
import base64
from Crypto.PublicKey import DSA
from Crypto.PublicKey import ECC
from Crypto.Hash      import SHA256
from Crypto.Signature import DSS, pss
from Crypto.Random    import get_random_bytes
from Crypto.Cipher    import AES, PKCS1_OAEP
import binascii
from pkcsfuncs import *

#
########################################################################
#
secret='c7675a2e6297b8e4990c0a29118914c0d4ee17ec'

#DDB_URL = "http://ddb.glidernet.org/download/?j=1"
DDB_URL = "http://acasado.es:60082/download/?j=2"  				# the OGN DDB source
REG_URL = "http://acasado.es:60080/registration/V1/?action=getdata&token="  	# the OGN registration source
#REG_URL = "http://localhost:8181/?action=getdata&token="  			# the OGN registration source

def getddbdata(reg):                        # get the data from the API server

    if reg == '':
       url=DDB_URL
    else:
       url=DDB_URL+'&registration='+reg
    req = urllib.request.Request(url)
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)         # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                  # convert to JSON

    return j_obj   

def getregdata(reg, mac, devid='', prt=False):         # get the data from the API servera
    date = datetime.utcnow()                # get the date
    dte = date.strftime("%Y-%m-%d")         # today's date
    nonce = base64.b64encode(dte.encode('utf-8')).decode('ascii')
    url=REG_URL+nonce
    if reg == '':                            # if registration is provided
       url=url+'&registration=NONE'
    else:
       url=url+'&registration='+reg
    url=url+'&mac='+mac+'&devid='+devid
    if prt:
       print("Calling to:",url)
    req = urllib.request.Request(url)        # prepare the request
    req.add_header("Accept", "application/json")  # it return a JSON string
    req.add_header("Content-Type", "application/hal+json")
    r = urllib.request.urlopen(req)          # open the url resource
    js=r.read().decode('UTF-8')
    j_obj = json.loads(js)                   # convert to JSON
    return j_obj   
#
# ----------------------------------------------------------------------------------------------------------
#
def genkeys():				                     # temp gen the keys
    listofkpECC=[]
    listofkpECC=ECCgenlistofkp(listofkpECC, 2)
    k      = listofkpECC[0]
    kk     = k['private_key'].encode('ascii')
    priecc = ECC.import_key(kk)
    kk     = k['public_key'].encode('ascii')
    pubecc = ECC.import_key(kk)
    return (priecc,pubecc)
    
def testsign(grec, prik, pubk, prt=False):	# temp test signture

    if prt:
      print("Has a valid key:", prik.has_private(), prik)

    h      = SHA256.new(grec.encode('ascii'))
    signer = DSS.new(prik, 'fips-186-3')
    signature = signer.sign(h)
    if prt:
       print ("Signature:",signature)
    return signature
#
# ----------------------------------------------------------------------------------------------------------
#
programver = 'V1.0'
pidfile="/tmp/TRKS.pid"
print("\n\nStart VALI-AVX  "+programver)
print("=====================")
################################################################
if os.name != 'nt':
   print("Program Version:", time.ctime(os.path.getmtime(__file__)))
   print("=========================================")
   import MySQLdb                       # the SQL data base routines^M
date = datetime.utcnow()                # get the date
dte = date.strftime("%y%m%d")           # today's date
print("\nDate: ", date, "UTC on SERVER:", socket.gethostname(), "Process ID:", os.getpid(), os.name)
date = datetime.now()                   # local time
parser = argparse.ArgumentParser(description="VALI-AVX validate the signature of the .IGC file generated by the OGN/IGC Tracker ")
parser.add_argument('-p',  '--print',     required=False,
                    dest='prttxt',   action='store', default=False)
parser.add_argument( dest='filename',   action='store', default='NOFILENAME')
args = parser.parse_args()
prttxt     = args.prttxt                # print on|off
if prttxt == 'True':
   prt=True
else:
   prt=False
filename   = args.filename              # FileName
if filename.find('.IGC') < 1:		       # check that is an IGC file
   print ("Wrong FileName:", filename)
   sys.stdout.flush()
   os._exit(-1)
try:
            f = open(filename, "rb")
except IOError as e:
            print(e)
            sys.stdout.flush()
            os._exit(-1)
data = f.read()				            # read the whole file
f.close()
sys.stdout.flush()
ddd=data.decode('ascii')		         # convert from binay to ASCII
print("** Validating: %s **" % filename)
limit=0
l = len(data) - 2

while l > 0:				               # scan for the G record (\nG)
     #print (data[l], data[l+1], l, data[l:].decode('ascii'))
     if data[l] == 71 and data[l-1] == 10: # G precceded by newline
        grec=data[l+1:-1].decode('ascii')
        limit=l
        break				               # found it
     l -= 1
h = hashlib.new('MD5')			         # use MD5
h.update(data[0:limit])			         # get the value
try:
        hexdigest = h.hexdigest()	   # get the message digest
except TypeError:
        hexdigest = h.hexdigest(128)
if prt:
   print("%s: %s" % ('MD5', hexdigest.upper()), len(hexdigest))
   print("%s: %s" % ('GRE', grec), len(grec))
   print()

if hexdigest.upper() == grec:		      # compare the values between the message disgest and the G record 
   print ("MD5 Signature OK")
else:
   print ("MD5 Signature wrong")
   sys.stdout.flush()
   os._exit(-1)

sys.stdout.flush()
l1=ddd.find('HFRHWHardwareVersion:FollowMe') 	# find the MAC value
MAC=""
if l1 > 0:
   l2=ddd[l1+30:].find('\n')
   MAC=ddd[l1+30:l1+l2+30]
if prt:
   print("MAC:", MAC)
l1=ddd.find('HFGIDGliderID:')		      # find the DEVICE ID
reg=""
if l1 > 0:
   l2=ddd[l1+14:].find('\n')
   reg=ddd[l1+14:l1+l2+14]
if prt:
   print("REG:", reg)			         # fine the registration ID
DDB=getddbdata(reg)			            # get the data from the Devices data Base (DDB)
dev=DDB['devices']
if prt:
   print("DDB:", dev)
devtype=dev[0]['device_type']		      # device type
devid=dev[0]['device_id']		         # deviceID
#print("DevT:", devtype, devid)
r=getregdata(reg, MAC, devid, prt=prt)	# get the data from the REGISTRATION database
rr=r['registration']
IPaddr=rr[0]['reg_IPaddr']		         # IP addr of when the device was registered
RegTime=rr[0]['reg_time']		         # Time of when it was registered
					                        # Public key from the device
PublicKey="-----BEGIN PUBLIC KEY-----\n"+rr[0]['reg_PublicKey']+"\n-----END PUBLIC KEY-----"
Rreg=rr[0]['reg_registration']		   # registration ID from the registration DB
Rdevid=rr[0]['reg_devid']		         # deviceID from the registration DB
if Rreg != reg or Rdevid != devid:	   # check if are the same ??
   print ("Invalid registration:", rr)
   sys.stdout.flush()
   os._exit(-1)
PublicKey=PublicKey.encode('ascii')	   # convert Public Key tp ASCII
if prt:
   print ("IP+RegTime+PK:",  IPaddr, RegTime, PublicKey)
pubecc = ECC.import_key(PublicKey)	   # get the PUBLIC KEY from the PEM format
if prt:
   print ("PublicKey:", pubecc)
h      = SHA256.new(grec.encode('ascii')) # get the MD from the G record
verifier = DSS.new(pubecc, 'fips-186-3') # build the ECDSA verifier
try:
   verifier.verify(h, grec)		      # verify the signature
   print ("The message is authentic.")
except ValueError:
   print ("The message is not authentic.")
sys.stdout.flush()
# ---------------------------------------    TEST    ------------------------------
#					Just a test of the concept
print ("======TEST=======")
prik,pubk=genkeys()			# genjust a pair of keys to test
sign=testsign(grec, prik, pubk, prt=prt)	# sign the G record just to test

h      = SHA256.new(grec.encode('ascii')) # get the MD of the G record
verifier = DSS.new(pubk, 'fips-186-3')	# ECDSA verifier
try:
   verifier.verify(h, sign)		# verify signature
   print ("The message is authentic.")
except ValueError:
   print ("The message is not authentic.")
print ("======TEST=======")
# ---------------------------------------    TEST    ------------------------------
sys.stdout.flush()
os._exit(0)
